#!/usr/bin/env perl
#
# KeyNanny provides a framework to protect sensitive data on a Unix host.
#
# Copyright (c) 2014 The CertNanny Project
# Authors: Martin Bartosch <m.bartosch@cynops.de>
#
# Licensed under the Apache License, Version 2.0 and the GNU General Public License, Version 2.0.
# See the LICENSE file for details.
#

package KeyNanny;

use strict;
use warnings;
use English;

use Carp;
use Getopt::Long;
use Config::IniFiles;
use Pod::Usage;
use File::Spec;
use File::Path;
use File::Temp;
use File::Glob qw( :glob );
use Sys::Syslog;
use Math::BigInt;

use Data::Dumper;

# optional: only required in lazy mode
# use Cache::Memcached;
# use Crypt::CBC;

use KeyNanny::Protocol;

use base qw( Net::Server::PreForkSimple );

my %options = (
    config => '/etc/keynanny/default.conf',
    );

my %config;
my %config_defaults = (
    # defaults
    keynanny => {
	cache_strategy => 'preload',
	log => 'syslog',
	debug => 0,
    },
    crypto => {
	openssl => '/usr/bin/openssl',
    },
    server => {
	proto => 'unix',
	socket_file => '$(keynanny.namespace).socket',
	pid_file => '$(keynanny.namespace).pid',
	background => 1,
	setsid => 1,
	max_servers => 3,
    },
    access => {
	read => 1,
	write => 0,
    }
    );


my $server_config;
my $namespace;
my $memd;
my $instance_cipher;
my $crypto_token;
my $cache;
my $log4perl_logger;


sub log_message {
    my $level = shift;
    my $message = shift;
    
    my $log_backend = $config{keynanny}->{log};

    # this hash allows remapping of levels for specific logger types
    my %level_map_of = (
	log4perl => {
	    'warning' => 'warn',
	    'notice'  => 'warn',
	}
	);

    if (exists $level_map_of{$log_backend}->{$level}) {
	$level = $level_map_of{$log_backend}->{$level};
    }
    
    if ($log_backend eq 'console') {
	print STDERR "$level: $message\n";
    } elsif ($log_backend eq 'syslog') {
	# syslog should not be given FATAL priorities
	syslog lc($level), '(' . $config{keynanny}->{namespace} . ') ' . $message;
    } elsif ($log_backend eq 'log4perl') {
	$log4perl_logger->$level($message);
    }
}

sub log_debug {
    my $arg = shift;
    return unless $config{keynanny}->{debug};
    log_message('debug', $arg);
}
sub log_info {
    my $arg = shift;
    log_message('info', $arg);
}
sub log_warn {
    my $arg = shift;
    log_message('warning', $arg);
}
sub log_notice {
    my $arg = shift;
    log_message('notice', $arg);
}
sub log_error {
    my $arg = shift;
    log_message('err', $arg);
}
sub log_fatal {
    my $arg = shift;
    log_message('crit', $arg);
}

sub get_random_bytes {
    my $arg = shift;
    
    if ($arg !~ m{ \A \d+ \z }xms) {
	log_fatal("Invalid parameter (only numbers accepted): $arg");
	die "Invalid parameter (only numbers accepted): $arg. Stopped";
    }
    
    my $value;

    if (-e '/dev/urandom') {
	open my $handle, '<', '/dev/urandom';
	read $handle, $value, $arg;
	close $handle;
    } else {
	my $openssl = $config{crypto}->{openssl};
	my $cmdline = "$openssl rand $arg";
	open my $handle, "$cmdline |";
	if (! $handle) {
	    log_fatal("Error running command: $cmdline");
	    die "Error running command: $cmdline";
	}
	if ($? != 0) {
	    log_fatal("Could not generate random data using openssl");
	    die "Could not genate random data using openssl";
	}
	read $handle, $value, $arg;
	close $handle;
    }
    
    if (defined $value && (length($value) == $arg)) {
	return $value;
    }

    log_fatal("Could not generate random data");
    die "Could not generate random data. Stopped";
}

sub _get_temp_filename {
    my $value;

    my $openssl = $config{crypto}->{openssl};
    my $cmdline = "$openssl rand -base64 48";
    open my $handle, "$cmdline |";
    if (! $handle) {
        log_fatal("Error running command: $cmdline");
        die "Error running command: $cmdline";
    }
    if ($? != 0) {
        log_fatal("Could not generate random data using openssl");
        die "Could not genate random data using openssl";
    }
    read $handle, $value, 64;
    close $handle;

    if (defined $value) {
        $value =~ s/\W/_/g;    # replace non-word chars with a safe underscore
        log_debug("Temporary filename: $value");
        return $value;
    }

    log_fatal("Could not generate temp file name");
    die "Could not generate temp file name. Stopped";
}

# changing a symlink is not an atomic operation on Linux, it's an
# unlink/link sequence which can create a race condition; this sub
# make symlinking atomic
sub _atomic_link {
    my $to = shift;
    my $from = shift;
    my $tmpfile = _get_temp_filename();

    log_debug("Symlinking $from to $to using temporary file $tmpfile");
    unless (symlink($to, $tmpfile)) {
      log_error("Unable to symlink ...");
      return 0;
    }
    unless (rename($tmpfile, $from)) {
      log_error("Unable to rename ...");
      return 0;
    }
    return 1;
}

sub _list_kn_objects {
    my $storage_path = shift;
    my @objects;
    my @robjects;

    my $find;
    opendir($find, $storage_path);
    if (! defined $find) {
	die "Could not scan storage directory $storage_path. Stopped";
    }

    my $entry;
    my $lentry;
    while ($lentry = readdir $find) {
	next if (($lentry eq '.') || ($lentry eq '..'));
        if ( -l "$storage_path/$lentry" ) {
            $entry = readlink "$storage_path/$lentry";
            $entry =~ s{ \A $storage_path/? }{}xms;    # remove the leading path part
        } else {
            $entry = $lentry;
        }
        if ( -d "$storage_path/$entry" ) {
            @robjects = _list_kn_objects("$storage_path/$lentry");
            s{ \A }{$lentry/}xms for @robjects;    # prefix the directory name to the results
            push @objects, @robjects;
        } else {
            chomp $lentry;
            push @objects, $lentry;
        }
    }
    close $find;

    s{ \A $storage_path/? }{}xms for @objects;    # remove the leading path part
    return @objects;
}


# store data at key := namespace:arg in (untrusted) cache
# cache is assumed to be publicly readable and writable, hence apply ample
# integrity protection
sub cache_store {
    my $arg = shift;
    my $data = shift;
    my $mtime = shift || time();

    return unless defined $data;

    my $namespace = $config{keynanny}->{namespace};

    # local caching first
    $cache->{$namespace}->{$arg}->{data} = $data;
    $cache->{$namespace}->{$arg}->{mtime} = $mtime;

    # memcache
    if (defined $memd) {
	my $id = "keynanny:$namespace:$arg:";
	
	my $encrypted = $instance_cipher->encrypt(length($id) . ':' . $id . $data);
	$memd->set($id, $encrypted);
    }
    return 1;
}

# retrieve data from cache at key := namespace:arg
sub cache_retrieve {
    my $arg = shift;

    my $namespace = $config{keynanny}->{namespace};

    # local caching first
    if (exists $cache->{$namespace}->{$arg}->{data}) {
	my $entry_mtime = persist_exists($arg);

	if (defined $entry_mtime) {
	    # log_debug("Storage/internal mtime for '$arg': $entry_mtime/$cache->{$namespace}->{$arg}->{mtime}");
    
	    if (defined $cache->{$namespace}->{$arg}->{mtime}
		&& ($cache->{$namespace}->{$arg}->{mtime} >= $entry_mtime)) {
		log_debug("Internal cache hit for $arg");
		return $cache->{$namespace}->{$arg}->{data};
	    }
	}
    }
    log_debug("Internal cache miss for $arg");

    # fallback to memcache
    if (defined $memd) {
	my $id = "keynanny:$namespace:$arg:";

	my $tmp = $memd->get($id);

	if (defined $tmp) {
	    # cache hit
	    log_debug("memcached hit for object $namespace.$arg");
	    my $decrypted = $instance_cipher->decrypt($tmp);
	    # check if we can actually decrypt the data

	    my $length;
	    my $data;
	    ($length, $data) = ($decrypted =~ m{ \A (\d+) : (.*) }xms);
	    
	    if (defined $length) {
		# length header found, extract stored key
		my $saved_id = substr($data, 0, $length);
		if ($saved_id eq $id) {
		    # authentic (stored id matches current)
		    log_debug("Integrity check successful for '$arg'");
		    return substr($data, $length);
		} else {
		    # sanity check failed, stored id does not match requested id
		    # (i. e. somebody tried to mess with the cache)
		    log_warn("Integrity check failed, invalidated cached value");
		    return;
		}
	    } else {
		log_debug("memcached miss for $arg");
		return;
	    }
	}
    }

    return;
}


# get list of token configuration hashes using the specified configuration file section
sub get_token {
    my $arg = shift;

    my @tokens;


    my $certglob_with_parens = $arg->{certificate};
    my $certglob_without_parens = $certglob_with_parens;
    # remove () from certificate file (to allow catching globbed substrings)
    $certglob_without_parens =~ s{ [()] }{}xmsg;

    foreach my $certfile (bsd_glob($certglob_without_parens)) {
	my %thistoken = %{$arg};

	my $re = glob_to_regex($certglob_with_parens, { ignore_parens_in_glob => 1 });
	if ($certfile =~ m{ $re }xms) {
	    my $keyfile = $arg->{key};
	    eval "\$keyfile=\"$keyfile\"";
	    # print "keyfile: $keyfile\n";
	    $thistoken{key} = $keyfile;
	}
	$thistoken{certificate} = $certfile;

	if (! -r $certfile) {
	    log_fatal("Could not read certificate $certfile");
	    die "Could not read certificate $certfile. Stopped";
	}

	my $cert = getcertinfo($certfile);
	if (! $cert) {
	    log_fatal("Could not parse certificate $certfile");
	    die "Could not parse certificate $certfile. Stopped";
	}

	log_info("Found certificate $certfile");
	log_info("Associated key: $thistoken{key}");

	$thistoken{certinfo} = $cert;

	push @tokens, \%thistoken;
    }
    return @tokens;
}

sub read_tokens {
    undef $crypto_token;

    if (! defined $config{crypto}->{token}) {
	die "No token configuration, cannot proceed. Stopped";
    }

    my @token_id = split('\s*,\s*', $config{crypto}->{token});

    my $max_notbefore = 0;

    # absolut token count
    my $token_index = 0;
    
    foreach my $id (@token_id) {
	# $id is the section name in the configuration file
	my $cert = $config{$id}->{certificate};
	my $key  = $config{$id}->{key};
	
	if (! defined $cert) {
	    die "No certificate defined in token section [$id]. Stopped";
	}
	if (! defined $key) {
	    die "No key defined in token section [$id]. Stopped";
	}

	# match all certificates referenced in this token section. 
	# this may be zero (not found), one (no wildcards) or many (certificate uses wildcards)
	my @tokens = get_token($config{$id});

	my $implicit_token_index = 0;
      TOKEN:
	foreach my $token (@tokens) {
	    # create lookup table
	    # certificate fingerprint is a unique handle, anything else could be ambiuous

	    my $subject  = $token->{certinfo}->{SubjectName};
	    my $issuer   = $token->{certinfo}->{IssuerName};
	    my $serial   = $token->{certinfo}->{Serial};
	    my $notbefore = $token->{certinfo}->{NotBefore};
	    my $notafter = $token->{certinfo}->{NotAfter};
	    my $fingerprint = $token->{certinfo}->{CertificateFingerprint};

	    if (defined $crypto_token->{cert}->{fingerprint}->{$fingerprint}) {
		log_info("Ignoring duplicate token $id subject: $subject");
		# already seen
		next TOKEN;
	    }

	    # record a field for token use, this is incremented on every token use (to catch unused tokens)
	    $token->{refcount} = 0;

	    # absolute token count
	    $token_index++;
	    
	    # implicit token count (one token section may reference many certificates)
	    $implicit_token_index++;

	    $crypto_token->{cert}->{fingerprint}->{$fingerprint} = $token;

	    # auxiliar data for statistics and cross referencing
	    # sequential token count
	    $crypto_token->{index}->{$token_index} = $crypto_token->{cert}->{fingerprint}->{$fingerprint};
	    # tokens ordered by section
	    push @{$crypto_token->{id}->{$id}},      $crypto_token->{cert}->{fingerprint}->{$fingerprint};

	    log_info("Token #$token_index: $id ($implicit_token_index) subject: $subject");

	    # identify latest certificate (to be used for new encryption)
	    if ($notbefore > $max_notbefore) {
		$max_notbefore = $notbefore;
		$crypto_token->{current_token} = $token;
	    }

	    # add index by issuer, serialnumber
	    $crypto_token->{cert}->{issuer}->{$issuer}->{serial}->{$serial} = 
		$crypto_token->{cert}->{fingerprint}->{$fingerprint};
	}
    }

    # debug: print all tokens
    #print Dumper $crypto_token; die;
}

# parse PEM encoded X.509v3 certificate and return certificate information 
# in a hash ref
# Prerequisites: requires external openssl executable
# arg: path to certificate
#
# return: hash reference containing the certificate information
#
# Returned hash reference contains the following values:
# Version => <cert version, optional> Values: 2, 3
# SubjectName => <cert subject common name>
# IssuerName => <cert issuer common name>
# SerialNumber => <cert serial number> Format: xx:xx:xx... (hex, upper case)
# Serial => <cert serial number> As integer number
# NotBefore => <cert validity> Format: YYYYDDMMHHMMSS
# NotAfter  => <cert validity> Format: YYYYDDMMHHMMSS
# PublicKey => <cert public key> Format: Base64 encoded (PEM)
# Certificate => <certifcate> Format: Base64 encoded (PEM)
# BasicConstraints => <cert basic constraints> Text (free style)
# KeyUsage => <cert key usage> Format: Text (free style)
# CertificateFingerprint => <cert SHA1 fingerprint> Format: xx:xx:xx... (hex, 
#   upper case)
#
# optional:
# SubjectAlternativeName => <cert alternative name> 
# IssuerAlternativeName => <issuer alternative name>
# SubjectKeyIdentifier => <X509v3 Subject Key Identifier>
# AuthorityKeyIdentifier => <X509v3 Authority Key Identifier>
# CRLDistributionPoints => <X509v3 CRL Distribution Points>
# 
sub getcertinfo {
    my $arg = shift;

    my $certinfo = {};
    my %month = (
		 Jan => 1, Feb => 2,  Mar => 3,  Apr => 4,
		 May => 5, Jun => 6,  Jul => 7,  Aug => 8,
		 Sep => 9, Oct => 10, Nov => 11, Dec => 12 );

    my %mapping = (
		   'serial' => 'SerialNumber',
		   'subject' => 'SubjectName',
		   'issuer' => 'IssuerName',
		   'notBefore' => 'NotBefore',
		   'notAfter' => 'NotAfter',
		   'SHA1 Fingerprint' => 'CertificateFingerprint',
		   'PUBLIC KEY' => 'PublicKey',
		   'CERTIFICATE' => 'Certificate',
		   'ISSUERALTNAME' => 'IssuerAlternativeName',
		   'SUBJECTALTNAME' => 'SubjectAlternativeName',
		   'BASICCONSTRAINTS' => 'BasicConstraints',
		   'SUBJECTKEYIDENTIFIER' => 'SubjectKeyIdentifier',
		   'AUTHORITYKEYIDENTIFIER' => 'AuthorityKeyIdentifier',
		   'CRLDISTRIBUTIONPOINTS' => 'CRLDistributionPoints',
		   );
	

    if (! defined $arg) {
	return;
    }
    
    my $openssl = $config{crypto}->{openssl};

    # export certificate
    my @cmd = (qq("$openssl"),
	       'x509',
	       '-in',
	       qq( $arg ),
	       '-inform',
	       'pem',
	       '-text',
	       '-subject',
	       '-issuer',
	       '-serial',
	       '-email',
	       '-startdate',
	       '-enddate',
	       '-modulus',
	       '-fingerprint','-sha1',
	       '-pubkey',
	       '-purpose',
	       );


    open my $fh, join(' ', @cmd) . '|';
    if (! $fh) {
	log_error("Error running command: " . join(" ", @cmd));
	return;
    }

    my $state = "";
    my @purposes;
    while (<$fh>)
    {
	chomp;
	tr/\r\n//d;

	$state = "DATA" if (/^\s*Data:/);
	$state = "PURPOSE" if (/^Certificate purposes:/);
	$state = "PUBLIC KEY" if (/^-----BEGIN PUBLIC KEY-----/);
	$state = "CERTIFICATE" if (/^-----BEGIN CERTIFICATE-----/);
	$state = "SUBJECTALTNAME" if (/X509v3 Subject Alternative Name:/);
	$state = "ISSUERALTNAME" if (/X509v3 Issuer Alternative Name:/);
	$state = "BASICCONSTRAINTS" if (/X509v3 Basic Constraints:/);
	$state = "SUBJECTKEYIDENTIFIER" if (/X509v3 Subject Key Identifier:/);
	$state = "AUTHORITYKEYIDENTIFIER" if (/X509v3 Authority Key Identifier:/);
	$state = "CRLDISTRIBUTIONPOINTS" if (/X509v3 CRL Distribution Points:/);

	if ($state eq "DATA") {
	}
	if ($state eq "PURPOSE")
	{
	    my ($purpose, $bool) = (/(.*?)\s*:\s*(Yes|No)/);
	    next unless defined $purpose;
	    push (@purposes, $purpose) if ($bool eq "Yes");

	    # NOTE: state machine will leave PURPOSE state on the assumption
	    # that 'OCSP helper CA' is the last cert purpose printed out
	    # by OpenCA. It would be best to have OpenSSL print out
	    # purpose information, just to be sure.
	    $state = "" if (/^OCSP helper CA :/);
	    next;
	}
	# Base64 encoded sections
	if ($state =~ /^(PUBLIC KEY|CERTIFICATE)$/)
	{
	    my $key = $state;
	    $key = $mapping{$key} if (exists $mapping{$key});

	    $certinfo->{$key} .= "\n" if (exists $certinfo->{$key});
	    $certinfo->{$key} .= $_ unless (/^-----/);

	    $state = "" if (/^-----END $state-----/);
	    next;
	}

	# X.509v3 extension one-liners
	if ($state =~ /^(SUBJECTALTNAME|ISSUERALTNAME|BASICCONSTRAINTS|SUBJECTKEYIDENTIFIER|AUTHORITYKEYIDENTIFIER|CRLDISTRIBUTIONPOINTS)$/)
	{
	    next if (/X509v3 .*:/);
	    my $key = $state;
	    $key = $mapping{$key} if (exists $mapping{$key});
	    # remove trailing and leading whitespace
	    s/^\s*//;
	    s/\s*$//;
	    $certinfo->{$key} = $_ unless ($_ eq "<EMPTY>");
	    
	    # alternative line consists of only one line 
	    $state = "";
	    next;
	}
	
 	if (/(Version:|subject=|issuer=|serial=|notBefore=|notAfter=|SHA1 Fingerprint=)\s*(.*)/)
 	{
	    my $key = $1;
 	    my $value = $2;
	    # remove trailing garbage
	    $key =~ s/[ :=]+$//;
	    # apply key mapping
	    $key = $mapping{$key} if (exists $mapping{$key});

	    # store value
 	    $certinfo->{$key} = $value;
 	}
    }
    $fh->close();

    # compose key usage text field
    $certinfo->{KeyUsage} = join(", ", @purposes);
    
    # sanity checks
    foreach my $var (qw(Version SerialNumber SubjectName IssuerName NotBefore NotAfter CertificateFingerprint))
    {
	if (! exists $certinfo->{$var})
	{
	    log_warn("getcertinfo(): Could not determine field '$var' from X.509 certificate\n");
	    return;
	}
    }


    ####
    # Postprocessing, rewrite certain fields

    ####
    # pad with a leading zero if length is odd
    if (length($certinfo->{SerialNumber}) % 2)
    {
	$certinfo->{SerialNumber} = '0' . $certinfo->{SerialNumber};
    }
    
    my $tmp = Math::BigInt->new('0x' . $certinfo->{SerialNumber});
    $certinfo->{Serial} = $tmp->bstr();

    # convert to upcase and insert colons to separate hex bytes
    $certinfo->{SerialNumber} = uc($certinfo->{SerialNumber});
    $certinfo->{SerialNumber} =~ s/(..)/$1:/g;
    $certinfo->{SerialNumber} =~ s/:$//;

    ####
    # get certificate version
    $certinfo->{Version} =~ s/(\d+).*/$1/;

    ####
    # reverse DN order returned by OpenSSL
    # foreach my $var qw(SubjectName IssuerName)
    # {
    # 	$certinfo->{$var} = join(", ", 
    # 				 reverse split(/[\/,]\s*/, $certinfo->{$var}));
    # 	# remove trailing garbage
    # 	$certinfo->{$var} =~ s/[, ]+$//;
    # }

    # Sanitize DNs
    foreach my $var (qw(SubjectName IssuerName))
    {
	$certinfo->{$var} =~ s{ \A /}{}xms;
    	$certinfo->{$var} =~ s{ / }{, }xmsg;
    }

    ####
    # rewrite dates from human readable to ISO notation
    foreach my $var (qw(NotBefore NotAfter))
    {
	my ($mon, $day, $hh, $mm, $ss, $year, $tz) =
	    $certinfo->{$var} =~ /(\S+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\d+)\s*(\S*)/;
	my $dmon = $month{$mon};
	if (! defined $dmon)
	{
	    log_warn("getcertinfo(): could not parse month '$mon' in date '$certinfo->{$var}' returned by OpenSSL");
	    return;
	}
	
	$certinfo->{$var} = sprintf("%04d%02d%02d%02d%02d%02d",
				    $year, $dmon, $day, $hh, $mm, $ss);
    }

    return $certinfo;
}



# parse CMS structure and return recipient information
# result structure: ARRAYREF of HASHREF
sub get_cms_recipient_info {
    my $arg = shift;
    my $openssl = $config{crypto}->{openssl};

    if (! -r $arg) {
	log_error("Could not read CMS file $arg");
	return;
    }

    my @cmd = (
	qq( $openssl ),
	'cms',
	'-in', qq( $arg ),
	'-inform', 'pem',
	'-cmsout', '-print',
	);
	
    
    my $cmdline = join(' ', @cmd);
    open my $handle, "$cmdline 2>/dev/null |";
    if (! $handle) {
	log_error("Error running command: $cmdline");
	return;
    }

    my $recipient_info;
    my $data;
  LINE:
    while (my $line = <$handle>) {
	chomp $line;
	next LINE if ($line =~ m{ \A \s* \z }xms);

	(my $indent, $line) = ($line =~ m{ \A (\s*) (.*) }xms);

	my $indentlevel = length($indent || '');

	if (my ($offset, $hexdata) = ($line =~ m{ \A ([0-9a-f]+) \s* - \s* ( (?:[0-9a-f][0-9a-f][ \-]){1,16} ) }xms)) {
	    # handle hexdumps
	} elsif (my ($tag, $value) = ($line =~ m{ ([^:]*) :? \s* (.*) }xms)) {
	    #print "tag: $tag, value: $value\n";
	    if ($tag =~ m{ issuerAndSerialNumber }xms) {
		if (defined $data) {
		    push @{$recipient_info}, $data;
		    undef $data;
		}
	    } elsif (($tag eq 'issuer') || ($tag eq 'serialNumber')) {
		$data->{$tag} = $value;
	    }
	} else {
	    log_warn("Could not parse CMS dump line $line");
	}

    }
    close $handle;

    if (defined $data) {
	push @{$recipient_info}, $data;
    }

    return $recipient_info;
}


# returns mtime of specified key if it exists, undef otherwise
sub persist_exists {
    my $key = shift;

    my $storage_path = $config{storage}->{dir};
    my $file = File::Spec->catfile($storage_path, $key);

    if (-r $file) {
	my $file_mtime = (stat($file))[9];
	return $file_mtime;
    }
    return;
}

# encrypt data for recipient and store result in persistent storage (directory $config{storage}->{dir})
# 
# arguments:
# 
sub persist_encrypt {
    my $key = shift;
    my $value = shift;

    # sanity checks: keys may only be word characters
    if ($key !~ m{ \A [\w/]+ \z }xms) {
	log_notice("Invalid characters in key $key");
	return;
    }

    my $openssl = $config{crypto}->{openssl};

    my $current_token = $crypto_token->{current_token};
    if (! defined $current_token) {
	log_fatal("No usable encryption token configured");
	return;
    }

    my $cert_file = $current_token->{certificate};

    if (! -r $cert_file) {
	log_error("Recipient certificate $cert_file not readable");
	return;
    }

    my $storage_path = $config{storage}->{dir};
    if (! -d $storage_path) {
	log_info("Storage path $storage_path does not exist, creating directories");
	if (File::Path->can('make_path')) {
	    File::Path->make_path($storage_path);
	} else {
	    # legacy mode
	    File::Path->mkpath($storage_path);
	}
    }

    my $file = File::Spec->catfile($storage_path, $key);

    log_debug("Storing data in CMS file $file");

    my @cmd = (
	qq( $openssl ),
	'smime', 
	'-encrypt',
	'-binary',
	'-aes256',
	'-out', qq( $file ),
	'-outform', 'pem',
	qq( $cert_file ),
	);

    my $cmdline = join(' ', @cmd);
    open my $handle, "| $cmdline";
    if (! $handle) {
	log_error("Error running command: $cmdline");
	return;
    }
    print $handle $value;
    close $handle;

    if ($? != 0) {
	log_error("Error running command (non-zero return code): $cmdline");
	return;
    }
    return 1;
}

# private method: decrypt data with specified token
sub _decrypt {
    my $token = shift;
    my $file = shift;

    my $openssl = $config{crypto}->{openssl};

    my @cmd = (
	qq( $openssl ),
	'smime',
	'-decrypt',
	'-inform', 'pem',
	'-in', qq( $file ),
	'-recip', qq( $token->{certificate} ),
	'-inkey', qq( $token->{key} ),
	);

    if (defined $token->{passphrase}) {
	push @cmd, 
	'-passin', 'env:PW';
	$ENV{PW} = $token->{passphrase};
    }

    my $config_file;
    if (defined $token->{engine}) {
	push @cmd,
	'-keyform', 'engine',
	'-engine', $token->{engine};
	
	# write openssl config if engine config is found
	my $engine_section = $token->{openssl_engine_config};
	if (defined $engine_section) {
	    if (! defined $config{$engine_section}) {
		log_error("Invalid engine section $engine_section referenced in token configuration");
		# trying to continue anyway
	    } else {
		my $fh = new File::Temp(
					UNLINK => 0,
					TEMPLATE => '/tmp/openssl-kn-engine-XXXXXXXX',
					);
		$config_file = $fh->filename;

		print $fh "openssl_conf = openssl_def\n";
		print $fh "[ openssl_def ]\n";
		print $fh "engines = engine_section\n";
		print $fh "[ engine_section ]\n";
		print $fh $token->{engine} . " = engine_config\n";
		print $fh "[ engine_config ]\n";

	        foreach my $key (keys %{$config{$engine_section}}) {
		    print $fh "$key = $config{$engine_section}->{$key}\n";
		}
		close $fh;

		$ENV{OPENSSL_CONF} = $config_file;
		log_debug("Wrote openssl config file $config_file");
	    }
	}
    }

    my $cmdline = join(' ', @cmd);
    open my $handle, $cmdline . ' 2>/dev/null |';
    if (! $handle) {
	log_error("Error running command: $cmdline");
	delete $ENV{PW};
	delete $ENV{OPENSSL_CONF};
	unlink $config_file if (defined $config_file && -e $config_file);
	return;
    }
    local $/;
    my $result = <$handle>;
    close $handle;

    delete $ENV{PW};
    delete $ENV{OPENSSL_CONF};
    unlink $config_file if (defined $config_file && -e $config_file);

    if ($? != 0) {
	log_error("Error running command (non-zero return code): $cmdline");
	return;
    }

    return $result;
}

sub persist_decrypt {
    my $key = shift;

    # sanity checks: keys may only be word characters
    if ($key !~ m{ \A [\w/]+ \z }xms) {
	log_notice("Invalid characters in key $key");
	return;
    }

    my $storage_path = $config{storage}->{dir};
    my $file = File::Spec->catfile($storage_path, $key);

    log_debug("Key '$key': Retrieving data from CMS file $file");

    my $recipient_info = get_cms_recipient_info($file);
    my $token;

    if (! defined $recipient_info) {
	log_info("Could not read recipient info from CMS file $file, trying all available tokens");
	# fall back to brute force (check all available certs)
	foreach my $fingerprint (keys %{$crypto_token->{cert}->{fingerprint}}) {
	    $token = $crypto_token->{cert}->{fingerprint}->{$fingerprint};
	    my $result = _decrypt($token, $file);
	    if (defined $result) {
		log_info("Key '$key': found suitable decryption token");

		# record token use for statistics
		$token->{refcount}++;

		return $result;
	    }
	}
	log_error("Key '$key': none of the configured tokens can decrypt file $file");
	return;
    } else {
	my $printable_recipients = '';
      RECIPIENT_INFO:
	foreach my $recipient (@{$recipient_info}) {
	    if (length $printable_recipients) {
		$printable_recipients .= '; ';
	    }
	    $printable_recipients .= 'Issuer: ' . $recipient->{issuer} . '/SerialNumber: ' . $recipient->{serialNumber};
	    if (exists $crypto_token->{cert}->{issuer}->{ $recipient->{issuer} }) {
		$token = $crypto_token->{cert}->{issuer}->{ $recipient->{issuer} }->{serial}->{ $recipient->{serialNumber} };
	    }
	    last RECIPIENT_INFO if defined $token;
	}
	if (! $token) {
	    log_error("Key '$key': cannot decrypt entry, none of the recipient certificates are available to keynanny: $printable_recipients");
	    return;
	}

	# record token use for statistics
	$token->{refcount}++;
    }

    return _decrypt($token, $file);
}

###########################################################################
# Convert shell glob to Perl regex, based on
# Text::Glob, written by Richard Clamp
#
sub glob_to_regex {
    my $glob = shift;
    my $options = shift || {};

    my $regex = glob_to_regex_string($glob, $options);
    return qr/^$regex$/;
}

# extended function to support capturing portions caught by wildcards
# options:
#   strict_leading_dots    default: 1
#   strict_wildcard_slash  default: 1
#   ignore_parens_in_glob  do not quote () parentheses in order to allow
#                          referencing matched portions (default: 0)
sub glob_to_regex_string
{
    my $glob = shift;
    my $options = shift || {};

    my $strict_leading_dot = 1;
    my $strict_wildcard_slash = 1;
    my $ignore_parens_in_glob = 0;

    if (exists $options->{strict_leading_dot}) {
	$strict_leading_dot = $options->{strict_leading_dot};
    }
    if (exists $options->{strict_wildcard_slash}) {
	$strict_wildcard_slash = $options->{strict_wildcard_slash};
    }
    if (exists $options->{ignore_parens_in_glob}) {
	$ignore_parens_in_glob = $options->{ignore_parens_in_glob};
    }

    my ($regex, $in_curlies, $escaping);
    local $_;
    my $first_byte = 1;
    for ($glob =~ m/(.)/gs) {
        if ($first_byte) {
            if ($strict_leading_dot) {
                $regex .= '(?=[^\.])' unless $_ eq '.';
            }
            $first_byte = 0;
        }
        if ($_ eq '/') {
            $first_byte = 1;
        }
        if ($_ eq '.' || $_ eq '|' ||
            $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
            $regex .= "\\$_";
        } 
	elsif (! $ignore_parens_in_glob && ($_ eq '(' || $_ eq ')')) {
            $regex .= "\\$_";
        }
        elsif ($_ eq '*') {
            $regex .= $escaping ? "\\*" :
		$strict_wildcard_slash ? "[^/]*" : ".*";
        }
        elsif ($_ eq '?') {
            $regex .= $escaping ? "\\?" :
              $strict_wildcard_slash ? "[^/]" : ".";
        }
        elsif ($_ eq '{') {
            $regex .= $escaping ? "\\{" : "(";
            ++$in_curlies unless $escaping;
        }
        elsif ($_ eq '}' && $in_curlies) {
            $regex .= $escaping ? "}" : ")";
            --$in_curlies unless $escaping;
        }
        elsif ($_ eq ',' && $in_curlies) {
            $regex .= $escaping ? "," : "|";
        }
        elsif ($_ eq "\\") {
            if ($escaping) {
                $regex .= "\\\\";
                $escaping = 0;
            }
            else {
                $escaping = 1;
            }
            next;
        }
        else {
            $regex .= $_;
            $escaping = 0;
        }
        $escaping = 0;
    }
#    print "# $glob $regex\n" if debug;

    return $regex;
}

###########################################################################

# ownership/mode for socket file
sub post_bind_hook {
    my $self = shift;

    if (defined $config{server}->{socket_mode}) {
	# evaluate in octal mode
	my $mode = oct($config{server}->{socket_mode});
	chmod $mode, $config{server}->{socket_file};
    }
}

# override display in process list for worker children
sub child_init_hook {
    my $self = shift;

    $0 = "keynannyd ($namespace) worker";
}

# reread tokens on server restart request
sub restart_open_hook {
    read_tokens;
}

sub process_request {
    my $self = shift;

    my $protocol_config = {};
    if (defined $log4perl_logger) {
	$protocol_config->{LOGGER} = $log4perl_logger;
    }

    my $protocol = KeyNanny::Protocol->new($protocol_config);

    eval {
	local $SIG{'ALRM'} = sub { die "TIMEOUT\n" };
	my $timeout = $config{server}->{timeout} || 10;

	my $previous_alarm = alarm($timeout);

      COMMAND:
	while (1) {
	    log_debug("Server $PID: idle");

	    my $request = $protocol->receive_command();
	    alarm($timeout);
	    if (! defined $request) {
		log_debug("Server $PID: client closed connection");
		last COMMAND;
	    }

	    if (! defined $request->{CMD}) {
		$protocol->send_response(
		    {
			STATUS => 'CLIENT_ERROR',
			MESSAGE => 'invalid command syntax',
		    });
		next COMMAND;
	    }

	    log_debug("Server $PID: received request " . $request->{CMD} . '(' . join(', ', @{$request->{ARG}}) . ')');

	    if ($request->{CMD} eq 'get') {
		if (! $config{access}->{read}) {
		    $protocol->send_response(
			{
			    STATUS => 'SERVER_ERROR',
			    MESSAGE => 'read access denied',
			});
		    next COMMAND;
		}

	      GET_ARG:
		foreach my $arg (@{$request->{ARG}}) {
		    if ($arg !~ m{ \A ([\w/]+) \z }xms) {
			$protocol->send_response(
			    {
				STATUS => 'CLIENT_ERROR',
				MESSAGE => 'invalid argument (alphanumeric and forward slashes only)',
			    });
			next GET_ARG;
		    }

		    my $data = cache_retrieve($arg);

                    if (! defined $data) {
                        # cache miss, get data from persistent store
                        if (persist_exists($arg)) {
                            # if it is encrypted, the file contents will start with '-----BEGIN PKCS7-----'
                            local $/;
                            open(my $enc_check, "$arg") or die "persist_exists says I can read but I cannot...";
                            $data = <$enc_check>;
                            close $enc_check;
                            if ($data =~ m /^-----BEGIN PKCS7-----/) {
                                $data = persist_decrypt($arg);
                                # cache retrieved value for later use
                                my $mtime = persist_exists($arg);
                                cache_store($arg, $data, $mtime);
                            }
                        }
                    }

		    if (defined $data) {
			$protocol->send_response(
			    {
				STATUS => 'OK',
				MESSAGE => length($data),
				DATA => $data,
				BINARY => 1,
			    });
		    } else {
			$protocol->send_response(
			    {
				STATUS => 'SERVER_ERROR',
				MESSAGE => 'entry not available',
			    });
			next GET_ARG;
		    }
		}
	    } elsif ($request->{CMD} eq 'set') {
		if (! $config{access}->{write}) {
		    $protocol->send_response(
			{
			    STATUS => 'SERVER_ERROR',
			    MESSAGE => 'write access denied',
			});
		    next COMMAND;
		}

		if (scalar @{$request->{ARG}} != 2) {
		    $protocol->send_response(
			{
			    STATUS => 'SERVER_ERROR',
			    MESSAGE => 'invalid number or arguments',
			});
		    next COMMAND;
		}

		my $arg = $request->{ARG}->[0];
		if ($arg !~ m{ \A ([\w/]+) \z }xms) {
		    $protocol->send_response(
			{
			    STATUS => 'CLIENT_ERROR',
			    MESSAGE => 'invalid argument key: alphanumeric and forward slashes only',
			});
		    next GET_ARG;
		}
		my $length = $request->{ARG}->[1];
		if ($length !~ m{ \A (\d+) \z }xms) {
		    $protocol->send_response(
			{
			    STATUS => 'CLIENT_ERROR',
			    MESSAGE => 'invalid argument length: numeric only',
			});
		    next GET_ARG;
		}

		# read payload
		my $data = $protocol->receive(
		    {
			LENGTH => $length, 
		    });

		if (defined $data) {
		    # persist value
		    if (persist_encrypt($arg, $data)) {

			# and cache it
			my $mtime = persist_exists($arg);
			cache_store($arg, $data, $mtime);
			$protocol->send_response(
			    {
				STATUS => 'OK',
			    });
		    } else {
			# read() did not succeed
			$protocol->send_response(
			    {
				STATUS => 'SERVER_ERROR',
				MESSAGE => 'communication error',
			    });
			next COMMAND;
		    }
		} else {
		    $protocol->send_response(
			{
			    STATUS => 'SERVER_ERROR',
			    MESSAGE => 'entry not stored',
			});
		    next COMMAND;
		}
            } elsif ($request->{CMD} eq 'link') {
                if (! $config{access}->{write}) {
                    $protocol->send_response(
                        {
                            STATUS => 'SERVER_ERROR',
                            MESSAGE => 'write access denied',
                        });
                    next COMMAND;
                }

                if (scalar @{$request->{ARG}} != 2) {
                    $protocol->send_response(
                        {
                            STATUS => 'SERVER_ERROR',
                            MESSAGE => 'invalid number or arguments',
                        });
                    next COMMAND;
                }

                my $storage_path = $config{storage}->{dir};
                my $to = $request->{ARG}->[0];
                if ($to !~ m{ \A ([\w/]+) \z }xms) {
                    $protocol->send_response(
                        {
                            STATUS => 'CLIENT_ERROR',
                            MESSAGE => 'invalid argument key: alphanumeric and forward slashes only',
                        });
                    next GET_ARG;
                }
                $to = File::Spec->catfile($storage_path, $to);
                my $from = $request->{ARG}->[1];
                if ($from !~ m{ \A ([\w/]+) \z }xms) {
                    $protocol->send_response(
                        {
                            STATUS => 'CLIENT_ERROR',
                            MESSAGE => 'invalid argument key: alphanumeric and forward slashes only',
                        });
                    next GET_ARG;
                }
                $from = File::Spec->catfile($storage_path, $from);

                if (_atomic_link($to, $from)) {
                    $protocol->send_response(
                        {
                            STATUS => 'OK',
                            MESSAGE => 0,
                        });
                } else {
                    $protocol->send_response(
                        {
                            STATUS => 'SERVER_ERROR',
                            MESSAGE => 'link failed',
                        });
                    next COMMAND;
                }
	    } elsif ($request->{CMD} eq 'list') {
		if (! $config{access}->{read}) {
		    $protocol->send_response(
			{
			    STATUS => 'SERVER_ERROR',
			    MESSAGE => 'read access denied',
			});
		    next COMMAND;
		}

		my @entries;
		my $storage_path = $config{storage}->{dir};
                @entries = _list_kn_objects($storage_path);
                unless (scalar @entries) {   # Empty array = read error
                    $protocol->send_response(
                        {
                            STATUS => 'SERVER_ERROR',
                            MESSAGE => 'cannot access storage',
                        });
                    next COMMAND;
                }

		my $data = join("\r\n", @entries);
		$protocol->send_response(
		    {
			STATUS => 'OK',
			MESSAGE => length($data),
			DATA => $data,
			BINARY => 1,
		    });
	    } elsif ($request->{CMD} eq 'ping') {
		$protocol->send_response(
		    {
			STATUS => 'OK',
		    });
		next COMMAND;
	    } elsif ($request->{CMD} eq 'quit') {
		$protocol->send_response(
		    {
			STATUS => 'OK',
		    });
		last COMMAND;
	    } else {
		$protocol->send_response(
		    {
			STATUS => 'CLIENT_ERROR',
			MESSAGE => 'unknown command',
		    });
		next COMMAND;
	    }
	}
    }; # eval
    if ($EVAL_ERROR =~ /TIMEOUT/) {
	# TODO: do we need to handle this?
	log_debug("Server $PID: timed out");
	return;
    }
    log_debug("Server $PID: exiting");
    return;
}

###########################################################################
# command line options
GetOptions(\%options,
	   'config=s',
	   'dumpconfig',
	   'check',
	   'rekey',
	   'debug',
	   'link',
	   'help',
	   'man');

pod2usage(
    {
	-exitval => 1,
	-verbose => 0,
    } ) if $options{help};

pod2usage(
    {
	-exitval => 1,
	-verbose => 2,
    } ) if $options{man};


###########################################################################

# return code, only used when not running as daemon (--check)
my $rc = 0;

# process configuration file
#read_config($options{config}, %config);
tie %config, 'Config::IniFiles', ( -file => $options{config} );

if (! scalar keys %config) {
    print join("\n", @Config::IniFiles::errors);
    die "Could not parse configuration file $options{config}";
}

# apply defaults
foreach my $section (keys %config_defaults) {
    foreach my $key (keys %{$config_defaults{$section}}) {
	if (! exists $config{$section}->{$key}) {
	    $config{$section}->{$key} = $config_defaults{$section}->{$key};
	}
    }
}

# use namespace if set in configuration...
$namespace ||= $config{keynanny}->{namespace};

# ... if not defined there, use configuration file base name
if (! defined $namespace) {
    my $configfile = $options{config};
    my ($vol, $dir, $filename) = File::Spec->splitpath($options{config});
    my $basename = $filename;
    $basename =~ s{ \. .*? \z }{}xms;
    $namespace = $basename;
}

# store namespace in config hash (if not already present)
$config{keynanny}->{namespace} = $namespace;

# postprocess config (replace referenced variables)
foreach my $section (keys %config) {
    foreach my $key (keys %{$config{$section}}) {
	my $entry = $config{$section}->{$key};
	while ($entry =~ m{ \$\((.*?)\) }xms) {
	    my $refvar = $1;

	    # check if referenced variable contains the section name
	    my $refsec = $section; # default: this section
	    my $refkey = $refvar;
	    if ($refvar =~ m{ \. }xms) {
		($refsec, $refkey) = ($refvar =~ m{ (.*?) \. (.*) \z }xms);
	    }
	    my $refval = $config{$refsec}->{$refkey} || '';

	    $entry =~ s{ \$\($refvar\) }{$refval}xms;
	}

	# replace closures
	if ($entry =~ m{ \A sub \s* \{ .* \} }xms) {
	    $entry = eval $entry;

	    if ($EVAL_ERROR) {
		die "Evaluation error in anonymous subroutine configured for $section:$key: " . $EVAL_ERROR;
	    }
	}	

	$config{$section}->{$key} = $entry;
    }
}

if ($options{dumpconfig}) {
    print Dumper \%config; 
    exit 0;
}

# if rekey is specified, also enable check option
if ($options{rekey}) {
    $options{check} = 1;
}

# if debug is specified override setting in config
if ($options{debug}) {
    $config{keynanny}->{debug} = 1;
}


# if check mode is required log to console and do not cache
if ($options{check}) {
    $config{keynanny}->{log} = 'console';
    $config{keynanny}->{cache_strategy} = 'preload';
}

if ($config{keynanny}->{log} !~ m{ \A (?:console|syslog|log4perl) \z}xms) {
    die "Invalid log configuration (expected: 'syslog', 'log4perl' or 'console'). Stopped";
}

if ($config{keynanny}->{log} eq 'syslog') {
    openlog 'keynannyd', 'ndelay,pid', 'local0';
}

if ($config{keynanny}->{log} eq 'log4perl') {
    # simulate 'use Log::Log4perl qw(:easy)'
    require Log::Log4perl;
    Log::Log4perl->import();
    if (! exists $config{keynanny}->{log4perlconfig}) {
	Log::Log4perl->easy_init();
    } else {
	Log::Log4perl::init($config{keynanny}->{log4perlconfig});
    }
    
    if (! exists $config{keynanny}->{log4perlconfig}) {
	$log4perl_logger = Log::Log4perl->get_logger();
    } else {
	my $log_category = $config{keynanny}->{log4perlcategory};
	$log4perl_logger = Log::Log4perl->get_logger($log_category);
    }
}


###########################################################################
# prepare crypto tokens
read_tokens;

###########################################################################
# prepare storage
my $storage_path = $config{storage}->{dir};
if (! -d $storage_path) {
    log_info("Storage path $storage_path does not exist, creating directories");
    if (File::Path->can('make_path')) {
	File::Path->make_path($storage_path);
    } else {
	# legacy mode
	File::Path->mkpath($storage_path);
    }
    
    # storage should be owned by daemon user/group
    my $storageuser = $EUID;
    my $storagegroup = $EGID;
    if (defined $config{server}->{user}) {
	$storageuser = getpwnam($config{server}->{user});
    }
    if (defined $config{server}->{group}) {
	$storagegroup = getgrnam($config{server}->{group});
    }

    # try to change ownership of storage dir
    log_info("Changing ownership or storage directory $storage_path to uid: $storageuser, gid: $storagegroup");
    chown $storageuser, $storagegroup, $storage_path;
}


###########################################################################
# initialize caching
if ($config{keynanny}->{cache_strategy} =~ m{ \A (?:preload|preload-relaxed) }xms) {
    # read all secrets in one go
    #
    # available strategies:
    # preload
    #   try to load all secrets, abort if there is at least one secret
    #   that is inaccessible
    #
    # preload-relaxed
    #   try to load all secrets, ignore secrets that cannot be unlocked

    log_debug("Scanning $storage_path for encrypted data objects");
    my $nok = 0;
    my $ok = 0;
    my $total = 0;

    my @objects = _list_kn_objects($storage_path);
    unless (scalar @objects) {   # Empty array = read error
        log_fatal("Unable to read KeyNanny objects. Aborting.");
        die "Unable to read KeyNanny objects. Aborting.";
    }
    my $entry;
    my $entry_mtime;
    my $data;
    foreach $entry (@objects) {
        $entry_mtime = persist_exists($entry);
        $total++;
        if (defined $entry_mtime) {
            # if it is encrypted, the file contents will start with '-----BEGIN PKCS7-----'
            local $/;
            open(my $enc_check, "$storage_path/$entry") or die "persist_exists says I can read but I cannot...";
            $data = <$enc_check>;
            close $enc_check;
            if ($data =~ m /^-----BEGIN PKCS7-----/) {
                $data = persist_decrypt("$entry");
            }
            # cache retrieved value for later use
            my $mtime = persist_exists("$storage_path/$entry");
            cache_store("$entry", $data, $mtime);
 
            if (defined $data) {
                $cache->{$namespace}->{$entry}->{data} = $data;
                $cache->{$namespace}->{$entry}->{mtime} = $entry_mtime;
                log_info("Entry '$entry': successfully decrypted and cached");
                $ok++;
            } else {
                log_warn("Entry '$entry': unable to decrypt entry (token unavailable)");
                $nok++;
            }
        }
    }
    
    log_info("Number of KeyNanny entries (total): $total");
    log_info("Number of KeyNanny entries (accessible): $ok");
    log_info("Number of KeyNanny entries (inaccessible): $nok");

    if ($nok) {
	log_warn("Unable to decrypt $nok KeyNanny entries");
	if ($config{keynanny}->{cache_strategy} eq 'preload') {
	    log_error("Strict checking enabled, exiting due to errors");
	    exit 1;
	}
    }

} elsif ($config{keynanny}->{cache_strategy} eq 'memcache') {
    ###########################################################################
    # prepare memcached connection
    my @memcached_servers = split(/\s*,\s*/, $config{memcache}->{servers});
    
    require Cache::Memcached;

    $memd = Cache::Memcached->new(
	{
	    'servers' => \@memcached_servers,
	});

    if (! defined $memd) {
	die "Could not instantiate memcached connection. Stopped";
    }

    ###########################################################################
    # prepare instance crypto key

    my $openssl = $config{crypto}->{openssl};
    if (! -x $openssl) {
	confess "Could not execute openssl at $openssl";
    }

    require Crypt::CBC;

    $instance_cipher = Crypt::CBC->new(
	-cipher      => 'Crypt::OpenSSL::AES',
	-literal_key => 1,
	-key         => get_random_bytes(32),
	-iv          => get_random_bytes(16),
	-header      => 'none',
	);
    
    if (! $instance_cipher) {
	die "Could not create cipher instance. Stopped";
    }

} else {
    die "Invalid cache strategy (expected: 'memcache', 'preload' or 'preload-relaxed'). Stopped";
}

if ($options{rekey}) {
    log_info("Rekeying stored entries");

    opendir(my $dh, $storage_path);
    if (! defined $dh) {
	die "Could not scan storage directory $storage_path. Stopped";
    }

    log_debug("Scanning $storage_path for encrypted data objects");
    my $nok = 0;
  DIR_ENTRY:
    while (my $entry  = readdir $dh) {
	next DIR_ENTRY if (($entry eq '.') || ($entry eq '..'));

	log_info("Rekeying $entry");
	my $entry_mtime = persist_exists($entry);
	if (defined $entry_mtime) {
	    my $data = persist_decrypt($entry);
	    if (defined $data) {
		log_info("Key '$entry': successfully rekeyed");
		persist_encrypt($entry, $data);
	    } else {
		log_error("Key '$entry': could not rekey entry (token unavailable?)");
		$nok++;
	    }
	}
    }
    closedir $dh;
    log_info("Rekeying finished with $nok errors");
    exit ($nok == 0);
}


if ($options{check}) {
    my $total = 0;
    my $inuse = 0;
    my $unused = 0;

    foreach my $index (sort keys %{$crypto_token->{index}}) {
	my $certificate = $crypto_token->{index}->{$index}->{certificate};
	my $refcount    = $crypto_token->{index}->{$index}->{refcount};

	my $usage;
	my $is_current = 'RETIRED';
	$total++;

	if ($crypto_token->{current_token} == $crypto_token->{index}->{$index}) {
	    # this token is the one with the highes NotBefore, i. e. the one which will be used
	    # for storing new entries
	    $is_current = 'CURRENT';
	}

	if ($refcount) {
	    $usage = "IN USE, REFCOUNT: $refcount";
	    $inuse++;
	} else {
	    $usage = "UNUSED";
	    $unused++;
	}
	log_info("Certificate $certificate: $is_current, $usage");
    }
    log_info("Number of configured tokens (total): " . $total);
    log_info("Number of configured tokens (in use): " . $inuse);
    log_info("Number of configured tokens (unused): " . $unused);

    log_info("Check finished. Exiting.");
#    print Dumper $crypto_token;
    exit $rc;
}


###########################################################################
# set umask
if (defined ($config{storage}->{umask})) {
    my $umask = oct($config{storage}->{umask});
    log_info("setting umask to $config{storage}->{umask}");
    umask $umask;
}

# prepare servers
$server_config = $config{server};
# custom options
if (defined $server_config->{socket_file}) {
    $server_config->{port} = $server_config->{socket_file} . '|unix';
} else {
    $server_config->{socket_file} = $server_config->{port};
    $server_config->{socket_file} =~ s/|.*$//g;
}
if (! defined $server_config->{pid_file}) {
    $server_config->{pid_file} = $server_config->{socket_file} . '.pid';
}

# override daemon user/group if not running as root
if ($EUID != 0) {
    log_info("running as non-privileged user");
    $server_config->{user} = $EUID;
    $server_config->{group} = $EGID;
}

KeyNanny->run(%{ $server_config });

__END__

=head1 NAME

keynannyd - KeyNanny credential protection daemon

=head1 SYNOPSIS

keynannyd [options]

  Options:
    --config FILE   keynannyd configuration file
    --check         perform tests on configuration and storage and print
                    summary
    --rekey         re-encrypt all encrypted data with the latest encryption
                    certificate
    --dumpconfig    print configuration summary (as Perl data structure)
    --debug         Enable debugging
    --help          brief help message
    --man           full manual page

=head1 OPTIONS

=over 8

=item B<--config FILE>

Read configuration from FILE. Default: /etc/keynanny/default.conf

=item B<--check>

Perform a complete initialization using the specified configuration,
including decryption of any values present in the configured storage
directory.

The --check command prints an overview on the configured tokens and
indicates the number of encrypted items which use the token.

Certificates which are reported to be UNUSED are not required by this
particular KeyNanny instance for decryption (but note that there may
be other instances sharing the same crypto tokens which possibly still
require the UNUSED tokens).

Exit with a non-zero return code if any errors are encountered (e. g.
not all values could be decrypted).

=item B<--rekey>

Iterate through all encrypted items and re-encrypt values with the latest
certificate. This operation is useful in order to retire older certificates
(which would otherwise have to be retained in order to decrypt older 
KeyNanny entries).

Exit with a non-zero return code if any errors are encountered (e. g.
not all values could be decrypted).

=item B<--dumpconfig>

Print the complete configuration as a Perl data structure and exits.

=item B<--help>

Print a brief help message and exit.

=item B<--man>

Prints the manual page and exits.

=back

=head1 DESCRIPTION

KeyNanny implements a server infrastructure component, consisting of a server process and several client programs which handles credential protection and access control using standard operating system paradigms and existing cryptographic standards.

=head2 Overview

KeyNanny addresses two common problems frequently encountered in server environments where duties (development, configuration management, deployment and operating) are separated between distinct user groups:

=over 4

=item * how can system credentials required by the server applications be protected from developers, ordinary users, administrators or possibly intruders

=item * how can system credentials or other credentials be securely exchanged between members of different operator groups

=back

In this context KeyNanny only addresses credentials that are used by programs, not by humans (e. g. the bind password of a technical LDAP account or a web server private key).

Often such credentials will simply be literally inserted into a configuration file so that the server process that needs to access a remote resource can readily use the required password - leaving the underlying system account open to unauthorized persons with read access to this configuration file:

=over 4

=item * unprivileged users on the same system might have access if permissions are too permissive

=item * configurations files may be backed up centrally where backup admins have access to the credentials within

=item * configuration files are sometimes checked into source code repositories, exposing the passwords to unauthorized access

=back

=head2 Design

KeyNanny cleverly combines standard features of Unix-like systems (such as file ownership and permissions, Unix interprocess communication and temp file systems) and cryptographic standards (CMS/PKCS#7) to build a credential management infrastructure that is easy to set up and understand for a Unix administrator.

The primary goal is to get rid of cleartext passwords and other sensitive information (e. g. cryptographic keys) in plain files stored on a server's disk or even a developer's workspace/repository.

In addition, KeyNanny also solves the problem of separating software deployment and server configuration from actual administration. With KeyNanny it is possible to manage the configuration files of a server system in a developer repository without storing any sensitive information in this repository.

An administrator can change the system credential without having to actually modify the configuration file.

The system implicitly solves the common problem how a password can be synchronized between two systems managed by different administrators. The password is encrypted by the person setting the password for the KeyNanny instance, and the result is a non-sensitive encrypted data structure which can only be accessed by the consumer of the password.


=head2 A word of caution

KeyNanny is not perfect. It gives administrators a toolbox to better protect system credentials, but in the end a system that is booting without user interaction will always be able to automatically deduce all credentials needed for operation. No matter how convoluted the setup, a skilled attacker will be able to peel away layer after layer until finally the actual credential is obtained.

Given the architecture of today's Unix system and application programs it is between hard and impossible to hide all credentials from unauthorized access. To solve this problem entirely, hardware cryptography is needed, and applications need to migrate away from password based authentication to public key authentication (e. g. TLS Client authentication).

=head2 Architecture

KeyNanny consists of the following components:

=head3 One KeyNanny daemon per "access namespace"

For each "namespace" (typically a server process or web application, e. g. apache or a webmail client) a dedicated KeyNanny daemon process will be running, configured from a namespace specific configuration file.

This namespace specific KeyNanny daemon will typically run as the same Unix user (and/or group) as the server process it shall support.

On startup the KeyNanny daemon will create a Unix domain socket through which clients can connect to the KeyNanny process and query credentials. This socket file must be properly protected by Unix permissions (can be configured in the instance configuration file).

An arbitrary number of parallel KeyNanny processes can be started independently, all serving different applications.

=head3 A persistent data store (aka directory with files in it)

This data store directory is used to persistently store the encrypted credentials for a namespace.
The contents of the data store are not sensitive, they may be world-readable (but they should be protected from unauthorized modification via proper Unix permissions).

Please note that different KeyNanny instances may share the same persistent data store. This may be useful in cases where distinct server processes are running (different Unix users), but it also allows a nifty use case: it is possible to configure one KeyNanny instance to serve the contents of a namespace read-only and have a different KeyNanny instance accessible for an administrator which has write-only access to the stored credentials. That way you could allow administrators to set applications passwords but not to read them.

=head3 One or more asymmetric cryptographic keys and corresponding certificates

Each KeyNanny instance needs at least one asymmetric key pair (e. g. RSA 2048) and a corresponding X.509v3 Certificate for the public key. The certificate may be self-signed, but a PKI signed certificate is fine as well.
KeyNanny supports an arbitrary number of encryption keys/certificates. If more than one certificate is configured, KeyNanny uses the one with the highest NotBefore date for encryption of newly set credentials.
"Old" certificates and keys should be retained as long as there is still data encrypted for these old keys.

KeyNanny is capable of automatically detecting the correct decryption certificate, but this only works properly with OpenSSL version 1.0 and higher (KeyNanny falls back to trying all keys sequentially until one works and is less efficient with older OpenSSL versions).

More than one KeyNanny instance can use the same cryptographic keys. In fact, this is recommended: configure all KeyNanny instances to point to the same keys to avoid excessive key management.

KeyNanny does _not_ honor the NotAfter date of certificates, nor does it consider CRLs, CA chains and trust management. 
There is little point in doing so with this particular encryption application anyway, and it is not useful to enforce such a behaviour in this particular case. If you wish to replace your keys regularly, simply add a new key/cert to the configuration and KeyNanny will use the new one automatically (if its NotBefore is higher than those of the existing certificates).

KeyNanny supports Hardware Security Modules via OpenSSL engine. In fact this is the recommended operation mode and the only way to get rid of storing a credential (password or key) unencrypted on disk.

You can configure KeyNanny to use "software" keys (i. e. RSA PEM files, possibly encrypted), but then you will have to either leave the key unencrypted or... write the password in KeyNanny's configuration file. Doh!

BTW, if you have stupid policies that prohibit this (which is impossible) you can sneak around this and Rot13 or Base64 your RSA password and store this obfuscated value in the KeyNanny configuration: KeyNanny is capable of evaluating Perl code in its configuration files - go figure...

=head3 Client programs talking to KeyNanny

While the task of the KeyNanny daemon is to manage decryption of credentials and limit access to these credentials, you will need clients connecting to KeyNanny to actually do something useful with it.

The KeyNanny project comes with 

=over 4

=item * a standalone command line client

=item * a Perl Connector implementation (https://github.com/mrscotty/connector)

=item * a Perl class that allows other Perl programs to talk to KeyNanny.

=back

In the future there may also be libraries for C, Python, Ruby and other commonly used languages.

The command line client can either obtain the raw value of a credential or it can be used to render a configuration file from a template, replacing contained variables with the values obtained from KeyNanny.


=head3 System runtime infrastructure

KeyNanny includes an init script that starts or stops all configured KeyNanny instances of a system at once. It is also possible to start/stop a single KeyNanny instance, though.

The init script checks if a standard shell rc script exists for any KeyNanny instance it tries to start/stop and execute the shell script (with the argument start/stop) when launching/stopping the KeyNanny daemon.

With this mechanism the system administrator can adapt how KeyNanny is integrated with the system. It allows to prepare temporary file systems, render configuration files replacing KeyNanny protected variables and or kick the application itself to reload its configuration file.

=head3 Grouping (directories)

KeyNanny allows you to group related information (secrets and metadata, see below) together in directories. These directories have no special meaning in KeyNanny and are treated simply as part of the name of an entity. KeyNanny entities are referred to by their path name relative to the applications storage directory.

Example: Application C<app1> has its data stored in C</var/lib/keynanny/storage/app1/>. In there we could have a directory called C<database> that stores the C<dbuser> and C<password> objects. These are then accessible via C<keynanny ... get database/dbuser> and C<keynanny ... get database/password>.


=head3 Metadata (unencrypted)

KeyNanny allows you to store metadata in the storage area. This metadata is not encrypted. To avoid storing secrets unencrypted by accident, KeyNanny will always encrypt data stored using C<keynanny ... set ...>. However, you can place unencrypted files in the storage area and KeyNanny will deliver them via the C<keynanny ... get ...> command. This allows you to put non-confidential information, such as a database username, alongside your secrets for easier management (see Symlinks).


=head3 Symlinks

To allow easy switching of credentials and to provide transactional (atomic) changes KeyNanny supports symbolic links (symlinks, as in C<ln -s>). Symlinks can point to files or directories and they are treated as if they were real. In other words, if you have a directory called C<orginal> and create a symlink by issuing C<ln -s original linked>, then C<linked> and its content is treated as if it were a directory. This allows for transactional changes of any number of credentials and metadata.

Example: Assume C<db1> is a directory containing encrypted credentials and unencrypted metadata for database access. C<db-current> is a symlink to C<db1>. The application uses C<db-current> to refer to the current configuration. When you need to change the password and/or metadata, you can copy C<db1> to C<db2> and make the necessary changes in there. Once done, re-link C<db-current> to C<db2>. The application will now use the new configuration.


=head2 Integration and use cases

=head3 Unmodified third party application, config files in temp file system

The standalone command line client is probably the most useful for unmodified applications which still require the configuration file in the application specific format, cleartext passwords included.

Here we assume that the application "demoapp" (running as Unix user demoapp and group nobody) requires two sensitive configuration items: 

=over 4

=item * a configuration file /etc/demoapp/demoapp.conf containing the passwords for an LDAP account, a web service and the password for the authkey file (variables "ldap", "webservice", "authkeypassphrase")

=item * a binary file containing a cryptographic key /etc/demoapp/authkey.pem (variable "authkey")

=back

The application requires that a lot of additional files in /etc/demoapp/, but none of those additional files contains sensitive information.

The integrator of the solution installs the demoapp application and prepares all the necessary files in /etc/demoapp, with the exception of /etc/demoapp/demoapp.conf and /etc/demoapp/client-key.pem.

The integrator then creates symlinks to a (not yet existing) directory:

    cd /etc/demoapp/
    ln -s /credentials/demoapp/demoapp.conf .
    ln -s /credentials/demoapp/authkey.pem .

This operation creates (dangling) symlinks in the application configuration directory.

Next, the integrator creates a file called /etc/demoapp/demoapp.conf.keynanny-template which contains exactly the required configuration.

In the template, appearances of the actual passwords are replaced with Template Toolkit variable references, e. g.:

    ...
    ldap_binduser = CN=Dummy App,O=KeyNanny,C=DE
    ldap_password = [% ldap %]
    ...
    webservice_url = https://soap.keynanny.example.com/service/...
    webservice_user = demoapp
    webservice_password = [% webservice %]
    webservice_clientcert = /etc/demoapp/client-cert.pem
    webservice_clientkey = /etc/demoapp/client-key.pem
...

Next the integrator creates the startup script for the KeyNanny instance. The keynanny distribution contains an example startscript app1.rc which provides a framework for rendering config files of an application to a tmp file system.


=head3 Direct integration of KeyNanny in shell scripts

For Unix shell scripts use the supplied keynanny binary. It can query the KeyNanny credentia lprotection daemon and outputs the returned secret to STDOUT:

  FOOBAR_VALUE=`keynanny --socketfile /var/lib/keynanny/run/app1.socket get foobar`
  if [ $? != 0 ] ; then
      echo "An error occurred"
      exit 1
  fi

=head3 Direct integration in B<Perl> applications using the supplied KeyNanny::Protocol module

  use KeyNanny;

  my $key = 'foobar';

  my $kn = KeyNanny->new( 
    { SOCKETFILE => '/var/lib/keynanny/run/app1.socket } );

  if (! defined $kn) {
      die "Could not instantiate KeyNanny. Stopped";
  }
  my $result = $kn->get($key);
  if (! defined $result) {
      die "Error communicating with KeyNanny. Stopped";
  }
  if ($result->{STATUS} ne 'OK') {
      die "KeyNanny error: " . $result->{STATUS} . ": " 
        . $result->{MESSAGE} . "\n";
  }
  my $value = $result->{DATA};

  print "secret stored for $key is $value\n";

=head3 Direct integation in C programs

TODO

=head3 Direct integation in Java programs

TODO

=head1 CONFIGURATION FILE

The configuration file uses the common ini file syntax. Section names are enclosed in square brackets, parameters within a section use the key = value syntax:

  [section]
  key = value

The following configuration directives may be used:

=head2 [keynanny]

=head3 B<namespace> = NAMESPACE

=over 4

Optional. Defaults to the basename of the configuration file.

Set the namespace keynanny will use. This influences the daemon process name and generated log entries and allows distinguishing multiple daemons on one system.

=back 

=head3 B<cache_strategy> = preload|preload-relaxed|memcache

=over 4

Optional. Defaults to 'preload'.

This configuration directive defines the behavior of keynanny when caching information.

B<preload>: On startup read all secrets, decrypt and cache them. Terminates with an error if a secret cannot be unlocked. This is the default.

B<preload-relaxed>: Like preload, but continues if a secret cannot be decrypted.

B<memcache>: Lazy loading of secrets (no preloading is done). Once a secret is requested, decrypt it and store the value using memcache. The values stored in memcache are encrypted with an ephemeral key only known to this particular keynanny instance. Data stored in memcache is integrity protected, attempted modification, replay or copying data to different values is not possible without keynanny noticing.

=back

=head3 B<log> = console|syslog|log4perl

=over 4

Optional. Defaults to 'syslog'. Select logging mechanism.


B<syslog>: Log to syslog (facility local0). This is the default.

B<console>: Log to STDOUT (not useful when running as a daemon)

B<log4perl>: Log using Log::Log4Perl

B<syslog>: Log to syslog (facility local0). This is the default.

=back

=head3 B<debug> = 0|1

=over 4

Optional. Defaults to 0.

Log debugging information (default: only level 'info' and higher).

Can be overridden by the --debug option.

=back

=head3 B<log4perlconfig> = FILE

=over 4

Optional. Only used when using Log::Log4Perl.

Specify the Log4Perl configuration file to use (only applicable for log = log4perl).

=back 

=head3 B<log4perlcategory> = CATEGORY

=over 4

Optional. Only used when using Log::Log4Perl.

Specify the Log4Perl category to use.

=back

=head2 [memcache]

Optional section. Only used when using the cache_strategy 'memcache'.

=head3 B<servers> = host, host, ...

=over 4

Comma separated list of memcache servers.

=back

=head2 [crypto]

=head3 B<openssl> = PATH_TO_OPENSSL

=over 4

Optional. Default: /usr/bin/openssl

Specify the path to openssl binary. Please note that OpenSSL versions 1.0 and higher are slightly more efficient because with these versions it is possible to deduce the recipient information from the encrypted blobs in the storage directory.

Previous versions will also work properly, but at the cost of some overhead: the keynannyd daemon will have to try all configured tokens to decrypt all available blobs.

=back

=head3 B<token> = CRYPTO_TOKEN1_SECTION, CRYPTO_TOKEN2_SECTION, ...

=over 4

Comma separated list of CRYPTO_TOKEN_SECTIONs which contain definitions of encryption certificates.

=back

=head2 [CRYPTO_TOKEN_SECTION]

A crypto token is configured in a distinct section whose name can be chosen by the administrator. The tokens to use by keynanny are configured in section [token] via token = ...

At least one CRYPTO_TOKEN_SECTION is required for keynanny to work properly.

Within the section the following keys are used:

=head3 B<certificate> = PATH_TO_CERTIFICATE

=over 4

Mandatory. KeyNanny needs at least one usable token to work properly.

Path to an encryption certificate used for decrypting the CMS encoded files in the storage directory.

On startup KeyNanny instantiates all crypto tokens and stores an internal reference about the certificate to be able to decrypt data from the storage directory. It is perfectly valid to have a larger number of certicates configured for KeyNanny. The correct decryption certificate will be used when reading values from the storage directory.

Storing new values will always be done using the certificate with the highest NotBefore date.

Keynanny does not perform any certificate chain validation or revocation checks! (In fact this is not very useful for this particular purpose.)

Please note that you may use Shell Globs to match multiple certificates at once. In order to make this useful, the globbing syntax is extended by allowing brackets () to capture the strings that are matched by the specified wildcards. The matched strings can then be used as $1, $2, ... in the B<key> definition.

Due to the special syntax processing it is not possible to use () brackets in the filename itself!

=back

=head3 B<key> = KEY_DEFINITION

=over 4

Mandatory.

Specification of the private key corresponding to B<certificate>. This may be the path to a RSA file or an identifier referencing a key in an HSM.

If the B<certificate> uses the Glogging feature (and captures the matched characters with brackets ()) then the matched strings can be referenced via $1, $2,... in B<key>

=back

=head3 B<passphrase> = KEY_PIN

=over 4

Optional.

Passphrase of the software RSA key specified in B<key>. 

=back

=head3 B<engine> = ENGINE

=over 4

Optional.

In order to use HSMs or Smartcards for protection of private keys it is necessary to specify the engine implementation to be used. For Thales nCipher HSMs you should set this value to "chil".

Very likely you will also have to specify an "engine section" for OpenSSL that initializes the crypto device to allow private key operations. To do so, point B<openssl_engine_config> to a section where the engine configuration is defined.

=back

=head3 B<openssl_engine_config> = [ENGINE_CONFIG_SECTION]

=over 4

Administrator chosen name of the section that contains the OpenSSL engine configuration. See section [ENGINE_CONFIG_SECTION].

=back

=head2 [ENGINE_CONFIG_SECTION]

The name of this section is chosen by the administrator. It is the name that is referenced by B<[crypto]> key openssl_engine_config.

This section contains arbitrary settings which will be literally propagated to the openssl configuration file and allows to pass options to (dynamic) engines.

The section may be referenced by any number of tokens.

=head2 [storage]

=head3 B<dir> = DIR

=over 4

Mandatory.

Base directory for reading/writing CMS blobs.

Please note that it is possible to have multiple keynanny instances pointing to the same storage directory (but with different user, group or access control settings)

=back

=head3 B<umask> = MODE

=over 4

Optional.

Octal umask to use when writing data to storage directory.

=back

=head2 [server]

=head3 B<socket_file> = PATH

=over 4

Mandatory.

Path of the Unix Domain Socket to listen on.

=back

=head3 B<socket_mode> = MODE

=over 4

Optional.

Octal mode that should be used to protect the keynanny socket file.

=back

=head3 B<timeout> = TIMEOUT

=over 4

Optional. Default: 10s

Timeout value for a server process. If a clients does not react within TIMOUT seconds the server closes the connection.

=back

=head3 B<user> = USER

=over 4

Unix user the daemon will change to before listening for connections. Typically this should be the user of the consuming application.

=back

=head3 B<group> = GROUP

=over 4

Unix group the daemon will change to before listening for connections. It is recommended to set this group to the same value (e. g. keynanny) for all keynanny instances on a host in order to allow the clients to write to the same run directory.

=back

=head3 B<pid_file> = PATH

=over 4

Location of the PID file written by the daemon.

=back

=head3 Additonal server configuration values

All other entries in the B<[server]> section are literally passed to Net::Server::PreFork. From the module configuration:

         min_servers         \d+                     5
         min_spare_servers   \d+                     2
         max_spare_servers   \d+                     10
         max_servers         \d+                     50
         max_requests        \d+                     1000


=head2 [access]

Access controls for clients connecting via the Unix Domain Socket.

=head3 B<read> = 0|1

=over 4

If set to 1 clients are allowed to read values from keynanny and obtain a list of the stored entries.

=back

=head3 B<write> = 0|1

=over 4

If set to 1 clients are allowed to set values via keynanny.

=back

=head1 EXAMPLE CONFIGURATION

  [keynanny]
  cache_strategy = preload
  log = syslog

  [crypto]
  openssl = /usr/bin/openssl
  base_dir = /var/lib/keynanny/crypto

  # reference all tokens to use
  token = mytoken, alltokens, hsmtoken

  # an explicitly configured token, held in software
  [mytoken]
  certificate = $(crypto.base_dir)/my-cert.pem
  key = $(crypto.base_dir)/my-key.pem
  passphrase = 1234

  # this is an implicit configuration for many certificates
  [alltokens]
  # match *keynanny*-cert.pem in crypto dir, and remember the strings matched as $1 and $2
  certificate = $(crypto.base_dir)/(*)keynanny(*)-cert.pem
  # ... and use these variables to reference the corrsponding key
  key = $(crypto.base_dir)/$1keynanny$2-key.pem

  # and now we use an nCipher HSM to protect the private key
  [hsmtoken]
  certificate = $(crypto.base_dir)/hsm-cert.pem
  key = hsm-key
  engine = chil
  openssl_engine_config = chil_engine

  [chil_engine]
  engine_id = chil
  dynamic_path = /usr/lib64/engines/libchil.so
  SO_PATH = /opt/nfast/toolkits/hwcrhk/libnfhwcrhk.so
  THREAD_LOCKING = 1

  [storage]
  dir = /var/lib/keynanny/storage/$(keynanny.namespace)

  [server]
  user = wwwown
  group = keynanny
  socket_mode = 0700

  socket_file = /var/lib/keynanny/run/$(keynanny.namespace).socket
  pid_file = /var/lib/keynanny/run/$(keynanny.namespace).pid
  background = 1
  max_servers = 4

  [access]
  read = 1
  write = 0
